__author__ = 'Victor Szczepanski'


from finite_grid_generation.utils import StateTransitionProbability, ObservationTransitionProbability


class GenerationHeuristicsFactory(object):
    def __init__(self):
        self.heuristics = {"reachable": ReachableBeliefs}

    def make_generation_heuristic(self, heuristic_name: str, **kwargs):
        if heuristic_name.lower() in self.heuristics:
            return self.heuristics[heuristic_name.lower()](kwargs)

        raise NotImplementedError("No heuristic implemented for strategy {}".format(heuristic_name))


class ReachableBeliefs(object):
    def __init__(self, states=(), actions=(), initial_belief_state=(), observations=(), state_transition_function=None,
                 observation_transition_function=None):
        self.states = states
        self.actions = actions
        self.initial_belief = initial_belief_state
        self.observations = observations
        self.state_transition_function = state_transition_function
        self.observation_transition_function = observation_transition_function


    def generate_grid(self, num_points=0, truncate=False, verbose=False):
        """
        Generate finite grid with `num_points` points.

        Uses a Breadth First Search type strategy for generating reachable belief states from `initial_belief`.
        If a belief state is reached again, we do not continue searching from it again.

        Args:
            num_points (int): the minimum number of grid points to generate. This function might generate more points, but will cease iterating once it has generated at least that many points.
            truncate (bool): truncate grid points to `num_points`. If True, will truncate the belief states generated to `num_points`.

        Returns:
            list[tuple[float]]: A list of belief states generated by breadth first search starting from `initial_belief`.
        """
        total_points = 0
        frontier = [self.initial_belief]
        visited = [self.initial_belief]
        while total_points < num_points:
            # dequeue belief state from frontier
            next_node = frontier.pop(0)

            #generate beliefs for every observation/action pair
            for observation in self.observations:
                for action in self.actions:
                    new_belief = belief_update(states=self.states, initial_belief=next_node, action=action,
                                               observation=observation,
                                               state_transition_function=self.state_transition_function,
                                               observation_transition_function=self.observation_transition_function,
                                               verbose=verbose)
                    #add it to queue if we haven't visited it before
                    if new_belief not in visited:
                        frontier.append(new_belief)
                        visited.append(new_belief)
                        total_points += 1
                    if truncate and total_points == num_points:
                        break

        return visited


def belief_update(states: tuple, initial_belief: tuple, action: str, observation: str, state_transition_function: StateTransitionProbability,
                  observation_transition_function: ObservationTransitionProbability, verbose=False) -> list:
    """
    Implement the belief update function.

    Implements
    ..math::
        b'(s') = \nu O(o | s',a) \sum_{s \in S} T(s' | s, a) b(s)
        \nu = 1/ Pr(o | b, a)
        Pr(o | b, a) = \sum_{s' \in S} O(o | s', a) \sum_{s \in S} T(s' | s, a)b(s)


    Args:
        states (tuple[str]): The states of the POMDP.
        initial_belief (tuple[float]): The initial belief state to generate the next belief state from
        action (str): The action to take
        observation (str): The observation made after taking action `action`.
        state_transition_function (StateTransitionProbability): The mapping
    Returns:
        list[float]: `b'`, as defined above. The next belief state.
    """

    nu = 0
    for s_prime in states:
        inner_sum = 0
        for s_index, s in enumerate(states):
            inner_sum += state_transition_function.T(s_prime=s_prime, s=s, a=action) * initial_belief[s_index]
        nu += observation_transition_function.O(o=observation, s_prime=s_prime, a=action) * inner_sum

    nu = 1.0/nu

    b_prime = []

    for s_prime in states:
        t_sum = 0.0
        for s_index, s in enumerate(states):
            t_sum += state_transition_function.T(s_prime=s_prime, s=s, a=action) * initial_belief[s_index]

        b_prime.append(nu * observation_transition_function.O(o=observation, s_prime=s_prime, a=action) * t_sum)

    if verbose:
            print("Generated new belief state {} from {}".format(b_prime, initial_belief))
    return b_prime
